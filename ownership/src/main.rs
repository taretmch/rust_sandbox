fn main() {
    //--------------------------------------------------------------------------
    // 所有権 (ownership) の規則
    //
    // 1) Rust の各値は、所有者と呼ばれる変数と対応している。
    // 2) いかなる時も所有者は一つである。
    // 3) 所有者がスコープから外れたら、値は破棄される。
    //
    // 変数のスコープは、スタックで管理される。
    // 文字列リテラル s は、不変の文字列である。
    let x = {
        // s はここから使える
        let s = "hello";
        println!("{}", s);
        s
    }; // s のスコープはここまで

    println!("The value of x is {}", x);
    //--------------------------------------------------------------------------

    // --[ String 型の所有権 ]--------------------------------------------------
    // String 型の所有権は、標準ライブラリや自作のデータ型にも適用される。
    // String 型は、ヒープ領域で管理される。

    // 文字列リテラルから String 型の値を生成する。
    // String::from の記法は、String 型直下の from 関数を呼び出すための記法。
    let mut s = String::from("hello");
    println!("The value of String variable s is {}", s);

    // String 型の文字列を可変にすると、ユーティリティメソッドが使える。
    // 文字列の後ろに文字列を連結させるには、push_str メソッドを用いる。
    s.push_str(", world!");

    println!("s is pushed new word. The value of it is {}", s);
    //--------------------------------------------------------------------------

    // --[ 文字列リテラルと String 型のメモリの扱い方の違い ]-------------------
    // 文字列リテラルはコンパイル時に、バイナリコードにハードコードされる。
    // String 型は可変かつ伸長可能な文字列をサポートするために、コンパイル時
    // 不明な量のメモリをヒープに確保して内容を保持する：
    // 1) メモリは、実行時に OS に要求される。
    // 2) String 型を使用し終わったら、OS にメモリを返還する。
    //
    // 1 のメモリ要求は、String::from 関数によって行われる。
    // 2 のメモリ返還は、ガベージコレクタがあるなら自動で行われる。
    // Rust では、スコープを抜けると自動でメモリが返還される。
    //
    // 変数がスコープを抜けるとき、drop という関数が呼ばれ、これがヒープに確保した
    // メモリを OS に返還する役割を担う (RAII; Resource Aquisition Is Initialization)。
    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    // 複数変数に同じ値を入れるときの作用
    // スタック領域を使う場合: 値5を代入した変数 x を別の変数 y に代入する
    // この場合、2つの5という値がスタックにプッシュされる。
    // 2つの生の値がスタックにあるだけなので、データのコピーも shallow copy, deep copy
    // とを区別する必要はない。
    let x = 5;
    let y = x;
    println!("The value of y is {}", y);

    // --[ ムーブ ]-------------------------------------------------------------
    // ヒープ領域を使う場合："hello"という String 型の値を代入した変数 s1 を別の変数 s2 に代入する
    // String 型は、3つの部品を持つ：
    // 1) ptr: 文字列の中身を保持するメモリへのポインタ
    // 2) len: 文字列の長さ
    // 3) capacity: 許容量
    //
    // 変数 s1 に代入すると、以上の3つのデータがスタックに蓄積される。
    // 次に、s1 を s2 に代入すると、その3つのデータがコピーされ、同じくスタックに蓄積される。
    // したがって、s2 が持つ ptr, len, capacity は s1 のものと全く同じで
    // 実際の文字列 "hello" のメモリ番地はどちらも同じである。
    //
    // しかし、変数がスコープを抜けるときヒープに確保した領域 (つまり、"hello"
    // という文字列が格納された番地) が解放される。
    // ところが、s1 と s2 どちらに対してもメモリ解放しようとすると、二重解放エラーが生じる。
    let s1 = String::from("hello");
    let s2 = s1;
    println!("s2: {}, world!", s2);

    // Rust において、s1 は s2 に代入された時点で参照が無効化される。
    //
    // ```
    // println!("s1: {}, world!", s1);
    // ```
    //
    // とすると、
    //
    // let s1 = String::from("hello");
    //     -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
    // let s2 = s1;
    //          -- value moved here
    // println!("s2: {}, world!", s2);
    // println!("s1: {}, world!", s1);
    //                     ^^ value borrowed here after move
    // 
    // というエラーが生じる。このように、s1 の参照が無効になり s2 に代入されることから
    // s1 は s2 にムーブされた、と表現できる。
    // したがって、二重解放エラーは起きず、変数のスコープを抜けると s2 だけがメモリ解放される。
    //--------------------------------------------------------------------------

    // --[ クローン ]-----------------------------------------------------------
    // 変数をムーブすることなく、ヒープデータの deep copy が必要な場合、clone
    // メソッドを用いることができる。
    // clone メソッドでは、ヒープデータが実際にコピーされている。
    let s1 = String::from("hello");
    let s2 = s1.clone();
    println!("s1 = {}, s2 = {}", s1, s2);
    //--------------------------------------------------------------------------

    // --[ Copy トレイトについて ]----------------------------------------------
    // Copy トレイトは、整数のようなスタックに保持される型に対して適合される。
    // Copy トレイトを実装していれば、代入後も古い変数を使用できる。
    // 型やその一部に Drop トレイトを実装すると、Copy トレイトによる注釈はできない。
    //
    // Copy の型の例:
    // - u32 などの整数型
    // - bool
    // - f64 などの浮動小数点型
    // - char
    // - Copy の型だけを含むタプル
    //--------------------------------------------------------------------------

    // --[ 関数呼び出しにおけるムーブ ]-----------------------------------------
    // 関数呼び出しにおいても、変数のムーブは行われる。
    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    // String 型を関数の引数として渡す場合
    // 1) 変数 s がスコープに入る。
    let s = String::from("hello");

    // 2) s の値が関数にムーブされる。
    takes_ownership(s);

    // 3) これ以降、s の参照は無効になる。ブロックの終了時に s はスコープを抜けるが
    // メモリ解放は特に行われない。
    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    // 整数型を関数の引数として渡す場合
    // 1) 変数 x がスコープに入る。
    let x = 5;

    // 2) x の値が関数にムーブされる。
    makes_copy(x);

    // 3) i32 は Copy なので、x はまだ使用可能である。
    println!("Since x implements Copy, then we can use it: {}", x);
    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    // 戻り値を返すことでも所有権は移動する。

    // 1) gives_ownership 関数からの戻り値を s1 にムーブする。
    let s1 = gives_ownership();

    // 2) s2 がスコープに入る。
    let s2 = String::from("hello");

    // 3) s2 を takes_ang_gives_back() 関数にムーブし、その戻り値を s3 にムーブする。
    let s3 = takes_and_gives_back(s2);

    // 4) これ以降、s2 の参照は無効である。s1 と s3 は参照可能である。
    // ブロックの終了時に s1, s2, s3 はスコープを抜け、s1 と s3 に対して drop が呼び出される。
    println!("s1 is {}, s3 is {}", s1, s3);
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
} // ここで some_string がスコープを抜け、`drop` が呼ばれる。

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
} // ここで some_integer がスコープを抜ける。特別なことはない。

fn gives_ownership() -> String {
    // some_string がスコープに入る。
    let some_string = String::from("hello");
    some_string
} // some_string が返され、呼び出し元関数にムーブされる。

// a_string がスコープに入る。
fn takes_and_gives_back(a_string: String) -> String {
    a_string
} // a_string が返され、呼び出し元関数にムーブされる。
