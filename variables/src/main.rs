fn main() {
    // --[ 不変変数と可変変数 ]-------------------------------------------------
    // 変数は let キーワードで宣言する
    // 不変変数として x を定義した場合
    // let x = 5;
    // x = 6;
    // のように代入するとコンパイルエラーになる
    let mut x = 5;
    println!("Tha value of x is {}", x); // => 5

    // mut によって x を可変変数として定義したので、代入できる。
    x = 6;
    println!("The value of x is {}", x); // => 6

    // --[ 定数 ]---------------------------------------------------------------
    // 定数は const キーワードで宣言する
    // 定数には必ず
    // 1) 型注釈をつけなければいけない
    // 2) 定数式にしかセットできない
    //
    // 定数の命名規則
    // 全て大文字で、単語はアンダースコア区切り
    const MAX_POINTS: u32 = 100_000;
    println!("The value of MAX_POINTS is {}", MAX_POINTS);

    // --[ シャドーイング ]-----------------------------------------------------
    // 前に定義した変数と同じ名前の変数を新しく宣言し、前の定義を覆い隠す（shadow）ことができる。
    let x = x + 1;
    println!("Tha value of x is {}", x); // => 7

    let x = x * 2;
    println!("Tha value of x is {}", x); // => 14

    // シャドーイングでは、再代入ではなく変数を生成しているので、異なる型の値を入れることができる。
    // 文字列型
    let spaces = "   ";
    // 数値型
    let spaces = spaces.len();
    println!("Tha length of spaces is {}", spaces); // => 14

    // --[ データ型: スカラー型 ]-----------------------------------------------
    // Rust には、4つのスカラー型がある:
    //
    // 1) 整数
    // 2) 浮動小数点数
    // 3) 論理値
    // 4) 文字

    // --[ スカラー型: 整数 ]---------------------------------------------------
    // +:---------:+:-----------:+:------------:+
    // |  大きさ   |   符号付き  |   符号なし   |
    // |:---------:|:-----------:|:------------:|
    // | 8-bit     | i8          | u8           |
    // | 16-bit    | i16         | u16          |
    // | 32-bit    | i32         | u32          |
    // | 64-bit    | i64         | u64          |
    // | arch      | isize       | usize        |
    // +-----------+-------------+--------------+
    //
    // arch は、コンピュータ依存のサイズを持つ。64ビットアーキテクチャなら64ビット。
    // 基準の型は i32
    //
    // 整数リテラルの記法
    // 10進数
    let dec_num  = 98_222;
    println!("Tha value of dec_num is {}", dec_num);

    // 16進数
    let hex_num  = 0xff;
    println!("Tha value of hex_num is {}", hex_num);

    // 8進数
    let oct_num  = 0o77;
    println!("Tha value of oct_num is {}", oct_num);

    // 2進数
    let bin_num  = 0b1111_0000;
    println!("Tha value of bin_num is {}", bin_num);

    // バイト
    let byte_num = b'A';
    println!("Tha value of byte_num is {}", byte_num);

    // --[ スカラー型: 浮動小数点数 ]-------------------------------------------
    // 2種類の基本型がある:
    // - f32: 32ビット単精度浮動小数点数。
    // - f64: 64ビット倍精度浮動小数点数。基本型
    //
    // 浮動小数点数は IEEE-754規格にしたがっている。

    // f64
    let float_num64 = 2.0;
    println!("Tha value of float_num64 is {}", float_num64);

    // f32
    let float_num32: f32 = 3.0;
    println!("Tha value of float_num32 is {}", float_num32);

    // --[ 数値演算 ]-----------------------------------------------------------
    // 基本の数値演算は足し算 (+)、引き算 (-)、掛け算 (*)、割り算 (/)、剰余 (%) である。
    println!("5 + 10      = {}", 5 + 10);
    println!("95.5 - 4.3  = {}", 95.5 - 4.3);
    println!("4 * 30      = {}", 4 * 30);
    println!("56.7 / 37.2 = {}", 56.7 / 37.2);
    println!("43 % 5      = {}", 43 % 5);

    // --[ スカラー型: 論理値型 ]-----------------------------------------------
    // Rust における論理値型は bool である。bool には2つの値がある:
    // true と false
    let t = true;
    let f: bool = false;
    println!("type bool is {} or {}", t, f);

    // --[ スカラー型: 文字型 ]-------------------------------------------------
    // Rust における文字型は char 型である。
    // char 型の値はユニコードのスカラー値を表す。
    // char 型の値はシングルクオートで宣言される。
    let c = 'z';
    let a = 'あ';
    let heart_eye_cat = '😻';
    println!("type char represents unicode characters such as {}, {} and {}", c, a, heart_eye_cat);

    // --[ 複合型 ]-------------------------------------------------------------
    // 複合型は、複数の値を一つの型にまとめるものである。
    // Rust にある2種類の基本的な複合型は、タプルと配列である。

    // --[ 複合型: タプル型 ]---------------------------------------------------
    // タプルは、() の中にカンマ区切りの値リストを書くことで生成する。
    // タプルの位置ごとに型があり、タプル内の値はそれぞれ全てが同じ型である必要はない。

    // 3-タプル
    let tup: (i32, f64, u8) = (500, 6.4, 1);

    // タプルは、パターンマッチにより各要素に分解する (分配という) ことができる
    let (_, y, _) = tup;
    println!("The second value of tuple is {}", y);

    // あるいは、ピリオドに続けて 0 から始まる添数を与えることによって要素にアクセスできる
    println!("The first  value of tuple is {}", tup.0);
    println!("The second value of tuple is {}", tup.1);
    println!("The third  value of tuple is {}", tup.2);

    // --[ 複合型: 配列型 ]-----------------------------------------------------
    // Rust の配列型は、タプルと異なり全ての値が同じ型でなければならない。
    // また、配列の長さは固定長である。
    //
    // 配列の長さが可変なコレクション型として、標準ライブラリによって提供されているベクタ型がある。
    let array = [1, 2, 3, 4, 5];

    // 配列の各要素に対して、添数によってアクセスできる
    println!("The first  value of array is {}", array[0]);
    println!("The second value of array is {}", array[1]);

    // 配列にない要素にアクセスしようとするとき、例えば array[5] とすると、
    //
    // |
    // |     array[5];
    // |     ^^^^^^^^ index out of bounds: the length is 5 but the index is 5
    // 
    // とコンパイルエラーが出る。添字が配列長より大きいとき、コンパイラはパニックする。
}
