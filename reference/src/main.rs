fn main() {
    //--------------------------------------------------------------------------
    // 変数の参照渡し
    let s1 = String::from("hello");
    
    // String 型でも、参照渡しすれば値はムーブされない。
    let len = calculate_length(&s1);

    // 参照渡ししたあとでも、変数は使用可能。
    println!("The length of {} is {}", s1, len);
    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    // 可変な参照
    // mut キーワードをつけることによって、参照も可変にできる。
    let mut s = String::from("hello");
    change(&mut s);
    println!("The value of mutable s is {}", s);

    // ただし、可変な参照は、1つしか作ることができない。
    //
    // ```
    // let r1 = &mut s;
    // let r2 = &mut s;
    // println!("{}, {}", r1, r2);
    // ```
    //
    // のように s への参照を2つ定義して使用すると、以下のようなエラーが出る。
    //
    // let r1 = &mut s;
    //          ------ first mutable borrow occurs here
    // let r2 = &mut s;
    //          ^^^^^^ second mutable borrow occurs here
    // println!("{}, {}", r1, r2);
    //                    -- first borrow later used here

    // この制約の利点は、コンパイラがコンパイル時にデータ競合を防ぐことができること。
    // そもそもデータ競合とは：
    // 1) 2つ以上のポインタが同じデータに同時にアクセスする。
    // 2) 少なくとも一つのポインタがデータに書き込みを行っている。
    // 3) データへのアクセスを同期する機構が使用されていない。
    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    // 可変な参照と不変な参照の組み合わせ

    // 不変な参照を複数定義するのは問題ないが
    let _r1 = &s;
    let _r2 = &s;
    // すでに不変な参照がある場合、可変な参照を定義できない
    //
    // ```
    // let _r3 = &mut s;
    // println!("{}, {}, {}", _r1, _r2, _r3);
    // ```
    // とすると、以下のようなエラーが出る。
    // let _r1 = &s;
    //           -- immutable borrow occurs here
    // 
    // let _r3 = &mut s;
    //           ^^^^^^ mutable borrow occurs here
    // println!("{}, {}, {}", _r1, _r2, _r3);
    //                        --- immutable borrow later used here
    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    // ダングリング参照の防止
    // ```
    // let reference_to_nothing = dangle();
    // 
    // fn dangle() -> &String {
    //     let s = String::from("hello");
    //     &s
    // }
    // ```
    // とすると、s はスコープから外れるので関数終了時に drop される。
    // したがって戻り値として参照を返せず、エラーになる。
    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    // 参照の規則
    // 1) 任意のタイミングで、一つの可変参照か不変な参照いくつでものどちらかを行える。
    // 2) 参照は常に有効でなければならない。
    //--------------------------------------------------------------------------
}

// 参照変数を引数としてとる関数
// s は、s1 へのポインタを持つようなデータ。つまり、
// String 型の ptr へのポインタを持つ。
fn calculate_length(s: &String) -> usize {
    s.len()
}

// 参照によって借用した値を変更することはできない。
// 参照も不変である。
// 
// ```
// fn change(some_string: &String) {
//     some_string.push_str(", world!");
// }
// ```
// とすると、以下のようなエラーが生じる。
//
// fn change(some_string: &String) {
//                        ------- help: consider changing this to be a mutable reference: `&mut String`
//       some_string.push_str(", world!");
//       ^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers to cannot be borrowed as mutable

// 可変な参照
fn change(some_string: &mut String) {
    some_string.push_str(", world!");
}
